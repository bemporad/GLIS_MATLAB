function [xopt,out]=glisp(pref0,lb,ub,opts)
% GLISp Solve (GL)obal optimization problems using (I)nverse distance
% weighting and radial basis function (S)urrogates and (p)reference
% queries. 
%
% The algorithm builds a surrogate of the latent function using radial
% basis functions (RBFs) that satisfies the expressed preferences at
% sampled points. The acquisition used to generate new samples is based
% either on inverse distance weighting (IDW) or probability of improvement
% (PI).
%
% The algorithm requires the Particle Swarm Optimization package PSwarm2.1
%
% http://www.norg.uminho.pt/aivaz/pswarm/software/PSwarmM_v2_1.zip
%
% or the Global Optimization package NLOPT
% 
% https://nlopt.readthedocs.io/
%
% installed to minimize the acquisition function.
%
% [xopt,out] = glisp(pref,lb,ub,opts) solves the active
% preference learning problem
%
% find x such that pref(x,y) <= 0 for all x,y in X,
% X = {x: lb <= x <=ub, A*x <=b, g(x)<=0}
% 
% where pref(x,y) = -1 if x "better than" y
%                    0 if x "as good as" y
%                    1 if x "worse than" y
% 
% A special case is to solve the global optimization problem
% 
% min  f(x)
% s.t. lb <= x <=ub, A*x <=b, g(x)<=0
% 
% based only on comparisons between function values
% 
% pref(x,y) = -1 if f(x1) <= f(x2) - tol
%           =  0 if |f(x1)-f(x2)| <= tol
%           =  1 if f(x1) >= f(x2) + tol      
% 
% where tol is the threshold deciding the outcome of the comparison,
% i.e., comparison is "even" if |f(x1)-f(x2)| <= tol
% 
% The algorithm is described in [1] and builds upon the global optimization
% algorithm described in [2] and is particularly useful when f(x) is not
% defined, but rather only comparisons between samples is available.
%
% The input argument opts specifies various parameters of the algorithm:
%
% opts.sepvalue      value used in constructing the surrogate function fhat:
%                    fhat(x1)<=fhat(x2)-sepvalue if pref(x1,x2) = -1
%                    |fhat(x1)-fhat(x2)|<=sepvalue if pref(x1,x2) = 0.
%
% For all other input arguments contained in structure opt
% and output argument type "help GLIS", with a few differences:
%
% opts.epsil:     epsil parameter used in defining RBF
%
% opts.rbf:       the RBF function also includes epsil as a parameter:
%                 rbf = fun(x1,x2,epsil)
%
% opts.RBFcalibrate: if true, recalibrate scaling parameter theta of RBF
%                 during iterations, i.e., fun(x1,x2,epsil*theta) is
%                 used as RBF.
%
% opts.thetas: array of theta values to test during calibration.
%              At least one element in thetas must be 1.
%
% opts.RBFcalibrationSteps: iterations at which RBF is recalibrated.
%              Values smaller than opts.nsamp are ignored.
%
% opts.comparetol: threshold to decide outcome of comparison during
%                  recalibration in cross validation, comparison is "even" if 
%                  |fhat(x1)-fhat(x2)|<=comparetol, fhat=surrogate function.
%
% opts.acquisition_method: acquisition method
%                 1 = scaled surrogate - delta * IDW
%                 2 = probability of improvement
%
% opts.svdtol:    not used.
% opts.alpha:     not used.
% opts.epsDeltaF: redundant epsDeltaF<=1.
% opts.useRBF:    forced to true.
% opts.globoptsol: global optimization package used to minimize the acquisition
%                  function, either 'pswarm' (PSwarm2.1) or 'direct' (NLOPT)
%
% The output argument 'out' is a structure reporting the following information:
%
% out.X:     trace of all samples x generated by the algorithm
% out.I:     results of comparisons: out.X(out.I(j,1)) "better than" out.X(out.I(j,2))
% out.Ieq:   results of comparisons: out.X(out.Ieq(j,1)) "as good as" out.X(out.Ieq(j,2))
% out.W:     final set of weights
% out.M      final RBF matrix
% out.xopt:  best sample found during search
% out.theta: scaling parameter multiplied by epsil in final RBF matrix
%
% [1] A. Bemporad, "Global optimization via inverse weighting and radial basis functions," 
% Computational Optimization and Applications, vol. 77, pp. 571–595.
% 
% [2] A. Bemporad and D. Piga, “Active preference learning based on radial basis functions,” 
% Machine Learning, vol. 110, no. 2, pp. 417–448, 2021, 
% Available on arXiv at http://arxiv.org/abs/1909.13049. 

%%%%%%%%%%%%%%%%%%%%%% 
% (C-GLISp)
% Note: Add features to handle unknown constraints (by M. Zhu, June, 03, 2021)
%       Known constraints will be handled via penalty functions
% 
% Following are the new parameters introduced in C-GLISp
% opts.isUnknownFeasibilityConstrained: if true, unknown feasibility constraints are involved
% opts.isUnknownSatisfactionConstrained: if true, unknown satisfaction constraints are involed
% delta_E: delta for te pure IDW exploration term, \delta_E in the paper
% delta_G_default: delta for feasibility constraints, \delta_{G,default} in the paper
% delta_S_default: delta for satisfaction constraints, \delta_{S,default} in the paper
% Feasibility_unkn: feasibility labels for unknown feasibility constraints
% SatConst_unkn: satisfaction labels for unknown satisfactory constraints


opts.useRBF=true;
opts.alpha=0; % dummy
if ~isfield(opts,'rbf') || isempty(opts.rbf)
    error('You need to specify a radial basis function');
end
rbf=opts.rbf;
if ~isfield(opts,'epsil') || isempty(opts.epsil)
    error('You need to specify the parameter epsil of the radial basis function');
end
epsil=opts.epsil;

opts.rbf=@(x1,x2) rbf(x1,x2,epsil);
[nvar,Aineq,bineq,g,isLinConstrained,isNLConstrained,...
    X,~,z,nsamp,maxevals,epsDeltaF,~,delta,rhoC,display,~,...
    dd,d0,~,~,M,scalevars,globoptsol,pswarm_vars,direct_vars,...
    isUnknownFeasibilityConstrained,isUnknownSatisfactionConstrained]=...
    glis_init(lb,ub,opts);

if ~isfield(opts,'sepvalue') || isempty(opts.sepvalue)
    sepvalue=1e-4;
else
    sepvalue=opts.sepvalue;
end

delta_E = delta; 
delta_G_default = delta; 
delta_S_default = delta/2;  


if scalevars
    pref=@(X,Y) pref0(X.*(ones(size(X,1),1)*dd')+ones(size(X,1),1)*d0',...
        Y.*(ones(size(Y,1),1)*dd')+ones(size(Y,1),1)*d0');
else
    pref=pref0;
end
if ~isfield(opts,'RBFcalibrate') || isempty(opts.RBFcalibrate)
    RBFcalibrate=false;
else
    RBFcalibrate=opts.RBFcalibrate;
end
if RBFcalibrate
    if ~isfield(opts,'thetas') || isempty(opts.thetas)
        error('Please provide opts.thetas for epsilon self-calibration in RBF');
    else
        thetas=opts.thetas;
        itheta=find(abs(thetas-1)<=1e-14);
        if isempty(itheta)
            error('At least one element in thetas must be equal to 1');
        end
        thetas(itheta)=1;
        MM=zeros(maxevals,maxevals,numel(thetas));
        iM=0; % index denoting the portion of MM already computed
    end
end
if ~isfield(opts,'RBFcalibrationSteps') || isempty(opts.RBFcalibrationSteps)
    RBFcalibrationSteps=nsamp+round([0;(maxevals-nsamp)/4;
    (maxevals-nsamp)/2;3*(maxevals-nsamp)/4]);
else
    RBFcalibrationSteps=opts.RBFcalibrationSteps;
end
if ~isfield(opts,'comparetol') || isempty(opts.comparetol)
    comparetol=1e-4;
else
    comparetol=opts.comparetol;
end
if ~isfield(opts,'acquisition_method') || isempty(opts.acquisition_method)
    acquisition_method=1;
else
    acquisition_method=opts.acquisition_method;
end


zbest=X(1,:)';
ibest=1;
I=[]; % I(i,1:2)=[h k] if F(h)<F(k)-comparetol
Ieq=[]; % Ieq(i,1:2)=[h k] if |F(h)-F(k)|<=comparetol
Feasibility_unkn = [];
SatConst_unkn = [];  
isfeas_seq = ones(maxevals,1); 
ibestseq = ones(maxevals,1); 

for i=2:nsamp
    if i ==2
        if isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained % when has both unknown feasibility and satisfactory constraints
            [prefi,fesi,fesbest,satconsti,satconstbest]=pref(X(i,:),zbest'); 
            SatConst_unkn = [SatConst_unkn;satconstbest]; 
            Feasibility_unkn=[Feasibility_unkn;fesbest];
        elseif ~isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained % when only has unknown feasibility constraints
            [prefi,fesi,fesbest]=pref(X(i,:),zbest'); 
            Feasibility_unkn=[Feasibility_unkn;fesbest];
        elseif isUnknownSatisfactionConstrained && ~isUnknownFeasibilityConstrained  % when only has unknown satisfactory constraints
            [prefi,satconsti,satconstbest]=pref(X(i,:),zbest');
            SatConst_unkn = [SatConst_unkn;satconstbest];
        else  % when there is no unknown constraints
           prefi=pref(X(i,:),zbest'); 
        end  
    else
        if isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained
            [prefi,fesi,~,satconsti,~]=pref(X(i,:),zbest');
        elseif ~isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained
           [prefi,fesi,~]=pref(X(i,:),zbest'); 
        elseif isUnknownSatisfactionConstrained && ~isUnknownFeasibilityConstrained
            [prefi,satconsti,~]=pref(X(i,:),zbest');
        else
            prefi=pref(X(i,:),zbest');
        end
    end
    if isUnknownFeasibilityConstrained
        Feasibility_unkn=[Feasibility_unkn;fesi]; 
    end
    if isUnknownSatisfactionConstrained
        SatConst_unkn = [SatConst_unkn;satconsti];
    end
    
    isfeas=true;
    % for known constraints (Note: no query is required for known constraints)
    if isLinConstrained
        isfeas=isfeas && all(Aineq*X(i,:)'<=bineq);
    end
    if isNLConstrained
        isfeas=isfeas && all(g(X(i,:)')<=0);
    end
    if isUnknownFeasibilityConstrained
        isfeas=isfeas && Feasibility_unkn(i) >0;
    end
    if isUnknownSatisfactionConstrained
        isfeas=isfeas && SatConst_unkn(i) >0;
    end
        
    if prefi==-1
        I=[I;i,ibest];
        zbest=X(i,:)';
        ibest=i;
    elseif prefi==1
        I=[I;ibest,i];
    else
        Ieq=[Ieq;i,ibest];
    end
    ibestseq(i) = ibest;
    isfeas_seq(i) = isfeas;
end

N=nsamp;

if RBFcalibrate
    [theta,itheta,M,MM,iM]=rbf_calibrate(X,I,Ieq,M,N,ibest,sepvalue,rbf,epsil,comparetol,display,thetas,MM,iM,itheta);
else
    theta=1;
end
W=get_weights(X,I,Ieq,M,N,ibest,sepvalue);

if isUnknownFeasibilityConstrained
    delta_G = get_deltaAdpt(X,Feasibility_unkn,delta_G_default);
else
    delta_G = 0;
end
if isUnknownSatisfactionConstrained
    delta_S = get_deltaAdpt(X,SatConst_unkn,delta_S_default);
else
    delta_S =0;
end

results_display(N,zbest,display,nvar,scalevars,dd,d0,theta*epsil,RBFcalibrate);

while N<maxevals
    % Compute range of current surrogate function
    FH=M(1:N,1:N)*W; % surrogate at current samples
    dF=max(max(FH)-min(FH),epsDeltaF);
    
    if isLinConstrained || isNLConstrained
        % penalty=rhoC*dF; % for GLIS
        penalty=rhoC; %for GLISp
    end
    if isLinConstrained && isNLConstrained
        constrpenalty=@(x) penalty*(sum(max(Aineq*x(:)-bineq,0).^2) +...
            sum(max(g(x(:)),0).^2));
    elseif isLinConstrained && ~isNLConstrained
        constrpenalty=@(x) penalty*(sum(max(Aineq*x(:)-bineq,0).^2));
    elseif ~isLinConstrained && isNLConstrained
        constrpenalty=@(x) penalty*sum(max(g(x(:)),0).^2);
    else
        constrpenalty=@(x) 0;
    end
    
    d_ibest=sum(([X(1:ibest-1,:);X(ibest+1:N,:)]-X(ibest,:)).^2,2); % exclude the ibest term in X when calculate d_ibest
    ii=find(d_ibest<1e-12,1);
    if ~isempty(ii)
        iw_ibest=0;
    else
        iw_ibest = 1/sum(1./d_ibest);
    end

    acquisition=@(x,p) facquisition_pref(x(:)',X,N,delta_E,dF,W,rbf,epsil,theta,sepvalue,ibest,acquisition_method,isUnknownFeasibilityConstrained,isUnknownSatisfactionConstrained,Feasibility_unkn,SatConst_unkn,delta_G,delta_S,iw_ibest,maxevals) + ...
        constrpenalty(x(:));
    
    switch globoptsol
        case 'pswarm'
            pswarm_vars.Problem.ObjFunction= @(x) facquisition_pref(x(:)',...
                X,N,delta_E,dF,W,rbf,epsil,theta,sepvalue,ibest,acquisition_method,isUnknownFeasibilityConstrained,isUnknownSatisfactionConstrained,Feasibility_unkn,SatConst_unkn,delta_G,delta_S,iw_ibest,maxevals)+constrpenalty(x(:));
            evalc('z=PSwarm(pswarm_vars.Problem,pswarm_vars.InitialPopulation,pswarm_vars.Options);');           
        case 'direct'
            direct_vars.opt.min_objective = acquisition;
            zold=z;
            z=nlopt_optimize(direct_vars.opt,zold);
            z=z(:);
    end
    
    N=N+1;
    X(N,:)=z';
    
    % Just update last row and column of M
    epsilth=epsil*theta;
    for h=1:N
        mij=rbf(X(h,:),X(N,:),epsilth);
        M(h,N)=mij;
        M(N,h)=mij;
    end
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Assessment of comparison %
    %%%%%%%%%%%%%%%%%%%f%%%%%%%%%
    
    N1=size(I,1);
   
    if isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained
        [prefN,fesN,~,satconstN,~] = pref(z',zbest'); % preference query
        
    elseif ~isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained
        [prefN,fesN,~] = pref(z',zbest'); % preference query
    elseif isUnknownSatisfactionConstrained && ~isUnknownFeasibilityConstrained
        [prefN,satconstN,~]=pref(z',zbest');
    else
        prefN = pref(z',zbest');
    end
    
    if isUnknownFeasibilityConstrained
        Feasibility_unkn(N) = fesN;
        delta_G = get_deltaAdpt(X,Feasibility_unkn,delta_G_default);
    else
        delta_G = 0;
    end
    
    if isUnknownSatisfactionConstrained
        SatConst_unkn(N) = satconstN;
        delta_S = get_deltaAdpt(X,SatConst_unkn,delta_S_default);
    else
        delta_S = 0;
    end
    
    isfeas=true;
    % for known constraints
    if isLinConstrained
        isfeas=isfeas && all(Aineq*z<=bineq);
    end
    if isNLConstrained
        isfeas=isfeas && all(g(z)<=0);
    end
    if isUnknownFeasibilityConstrained
        isfeas=isfeas && Feasibility_unkn(N) >0;
    end
    if isUnknownSatisfactionConstrained
        isfeas=isfeas && SatConst_unkn(N) >0;
    end

    if prefN==-1
        I(N1+1,1:2)=[N,ibest];
        zbest=z;
        ibest=N;
    elseif prefN==1
        I(N1+1,1:2)=[ibest,N];
    else
        Ieq(end+1,1:2)=[ibest,N];
    end
    
    ibestseq(N) = ibest;
    isfeas_seq(N)= isfeas;

    if RBFcalibrate && any(N==RBFcalibrationSteps)
        [theta,itheta,M,MM,iM]=rbf_calibrate(X,I,Ieq,M,N,ibest,sepvalue,rbf,epsil,comparetol,display,thetas,MM,iM,itheta); 
    end
    W=get_weights(X,I,Ieq,M,N,ibest,sepvalue);
    
    results_display(N,z,display,nvar,scalevars,dd,d0,theta*epsil,RBFcalibrate);
end

xopt=zbest;
if ~isUnknownFeasibilityConstrained
    Feasibility_unkn = ones(maxevals,1);
end
if ~isUnknownSatisfactionConstrained && ~isUnknownFeasibilityConstrained
    SatConst_unkn = ones(maxevals,1);
elseif ~isUnknownSatisfactionConstrained && isUnknownFeasibilityConstrained
    SatConst_unkn = Feasibility_unkn;
end

fes_opt_unkn = Feasibility_unkn(ibest);
satConst_opt_unkn = SatConst_unkn(ibest);
feas_opt_comb = isfeas_seq(ibest);

if scalevars
    % Scale variables back
    xopt=xopt.*dd+d0;
    X=X.*(ones(N,1)*dd')+ones(N,1)*d0';
end

out=struct('X',X,'W',W,'M',M,'xopt',xopt,'ibest',ibest,'ibestseq',ibestseq,...
    'I',I,'Ieq',Ieq,'theta',theta,'Feasibility_unkn',Feasibility_unkn,'SatConst_unkn',SatConst_unkn,...
    'fes_opt_unkn',fes_opt_unkn,'satConst_opt_unkn',satConst_opt_unkn,'isfeas_seq',isfeas_seq,'feas_opt_comb',feas_opt_comb);

%%%%%%%%%%%%%%%%%%%%%%
function delta_adpt = get_deltaAdpt(X,constraint_set,delta_const_default)
% Adaptively tune the hyperparameter delta_G and delta_S for the feasibility and satisfaction term in the acquisition function
% For both terms, their delta is tuned via leave-one-out cross validation using IDW interpolation as a prediction method

ind = size(constraint_set,1);
sqr_error_feas = zeros(ind,1);
for i= 1:ind
    xx = X(i,:);
    Xi = [X(1:i-1,:); X(i + 1:ind,:)];
    const_classifier_i = [constraint_set(1:i-1);constraint_set(i+1:ind)];
    Feas_xx = constraint_set(i);
    d = sum((Xi - xx).^2,2);
    w = exp(-d)./d;
    sw = sum(w);
    ghat = sum(const_classifier_i'* w) / sw;
    sqr_error_feas(i) = (ghat-Feas_xx)^2;
end

std_feas = min(1,(sum(sqr_error_feas)/(ind-1))^(1/2));
delta_adpt = (1-std_feas) *delta_const_default;


%%%%%%%%%%%%%%%%%%%%%%
function [f,fhat,dhat]=facquisition_pref(x,X,N,delta_E,dF,beta,rbf,epsil,...
    theta,sepvalue,ibest,acquisition_method,isUnknownFeasibilityConstrained,isUnknownSatisfactionConstrained,Feasibility_unkn,SatConst_unkn,delta_G,delta_S,iw_ibest,maxevals)
% Acquisition function to minimize to get next sample
%
% 1: a(x) = scaled surrogate + delta_E * z_N + delta_G * (1-G_hat) + delta_S * (1-S_hat)
% 2: a(x) = probability of improvement
            
m=size(x,1); % number of points x to evaluate the acquisition function

f=zeros(m,1);
v=zeros(N,1);

epsilth=epsil*theta;

for i=1:m
    xx=x(i,:)';
    
    if acquisition_method==1
        for j=1:N
            v(j)=rbf(X(j,:),xx',epsilth);
        end
        fhat=v'*beta;
        d=sum((X(1:N,:)-ones(N,1)*xx').^2,2);
        ii=find(d<1e-12,1);
        if ~isempty(ii)
            dhat=0;
            if isUnknownFeasibilityConstrained
                Ghat=Feasibility_unkn(ii);
            else
                Ghat=1;
            end
            if isUnknownSatisfactionConstrained
                Shat=SatConst_unkn(ii);
            else
                Shat=1;
            end
        else
            w=exp(-d)./d;
            sw=sum(w);
            if maxevals <= 30
                dhat = delta_E *atan(1/sum(1./d)); %for comparision, used in the original GLISp and when N_max <= 30 in C-GLISp
            else
                dhat = delta_E * ((1-N/maxevals)*atan((1/sum(1./d))/iw_ibest)+ N/maxevals *atan(1/sum(1./d))); % used in C-GLISp
            end
            
            if isUnknownFeasibilityConstrained
                Ghat=sum(Feasibility_unkn(1:N)'*w)/sw;
            else
                Ghat = 1;
            end  

            if isUnknownSatisfactionConstrained
                Shat=sum(SatConst_unkn(1:N)'*w)/sw;
            else
                Shat = 1;
            end
        end
        
%         f(i)=fhat/dF-dhat; % for comparision, used in GLISp
        f(i)=fhat/dF-dhat+delta_G*(1-Ghat)+delta_S*(1-Shat); % used in C-GLISp
  
    elseif acquisition_method==2
        PHIbeta=0;
        for j=1:N
            PHIbeta=PHIbeta+(rbf(X(j,:),xx',epsilth)-rbf(X(j,:),X(ibest,:),epsilth))*beta(j);
        end
        lm1=max(PHIbeta+sepvalue,0);
        l0=max([0;PHIbeta-sepvalue;-PHIbeta-sepvalue]);
        l1=max(sepvalue-PHIbeta,0);
        c0=1;
        cm1=1;
        c1=1;
        em1=exp(-cm1*lm1);

        f(i)=-em1/(em1+exp(-c0*l0)+exp(-c1*l1));
    end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function beta=get_weights(X,I,Ieq,M,n,ibest,sepvalue)
% Fit RBF satisfying comparison constraints at sampled points

% optimization vector x=[beta;epsil] where:
%    beta  = rbf coefficients
%    epsil = vector of slack vars, one per constraint

normalize=0;

m=size(I,1);
meq=size(Ieq,1);
A=zeros(m+2*meq,n+m+meq);
b=zeros(m+2*meq,1);
for k=1:m
    i=I(k,1);
    j=I(k,2);
    % f(x(i))<f(x(j))
    % sum_h(beta(h)*phi(x(i,:),x(h,:))+a'*x(i,:)'+b'*(x(i,:)').^2
    % <= sum_h(beta(h)*phi(x(j,:),x(h,:))+a'*x(j,:)'+b'*(x(j,:)').^2
    %    +eps_k-sepvalue
    A(k,:)=[M(i,1:n)-M(j,1:n) zeros(1,k-1) -1 zeros(1,m+meq-k)];
    b(k)=-sepvalue;
end


% |f(x(i))-f(x(j))|<=comparetol
% --> f(x(i))<=f(x(j))+comparetol+epsil
% --> f(x(j))<=f(x(i))+comparetol+epsil
%
% sum_h(beta(h)*phi(x(i,:),x(h,:))+a'*x(i,:)'+b'*(x(i,:)').^2
% <= sum_h(beta(h)*phi(x(j,:),x(h,:))+a'*x(j,:)'+b'*(x(j,:)').^2+sepvalue+epsil
%
% sum_h(beta(h)*phi(x(j,:),x(h,:))+a'*x(i,:)'+b'*(x(i,:)').^2
% <= sum_h(beta(h)*phi(x(i,:),x(h,:))+a'*x(j,:)'+b'*(x(j,:)').^2+sepvalue+epsil

for k=1:meq
    i=Ieq(k,1);
    j=Ieq(k,2);
    A(m+2*(k-1)+1,:)=[M(i,1:n)-M(j,1:n) zeros(1,m+k-1) -1 zeros(1,meq-k)];
    A(m+2*k,:)=[M(j,1:n)-M(i,1:n) zeros(1,m+k-1) -1 zeros(1,meq-k)];
    b(m+2*(k-1)+1)=sepvalue;
    b(m+2*k)=sepvalue;
end

if normalize
    % Add constraints to avoid trivial solution surrogate=flat:
    %    sum_h(beta.*phi(x(ibest,:),x(h,:)))+a'*x(ibest,:)'+b'*(x(ibest,:)').^2  = 0
    %    sum_h(beta.*phi(x(ii,:),x(h,:)))+a'*x(ii,:)'+b'*(x(ii,:)').^2  = 1
    % Look for sample where function is worse
    ii=I(1,2);
    for k=1:m
        if I(k,1)==ii
            ii=I(k,2);
        end
    end
    Aeq=[M(ibest,1:n) zeros(1,m+meq);
        M(ii,1:n) zeros(1,m+meq)];
    beq=[0;
        1];
else
    Aeq=[];
    beq=[];
end
% Only impose surrogate=0 at x(ibest):
% Aeq=[M(ibest,1:n) zeros(1,m+meq)];
% beq=0;

e=ones(m+meq,1);
% penalize more violations involving zbest
if ~isempty(I)
    ii=(I(:,1)==ibest | I(:,2)==ibest);
    e(ii)=10;
end
if ~isempty(Ieq)
    ii=(Ieq(:,1)==ibest | Ieq(:,2)==ibest);
    e(m+ii)=10;
end

lb=[-inf(n,1);zeros(m+meq,1)]; % slacks >=0
c=[zeros(1,n) e'];

% solve QP with penalty on beta only, QUADPROG
opts=struct('Display','off');
xopt=quadprog(diag([1e-6*ones(n,1);zeros(m+meq,1)]),c,A,b,Aeq,beq,lb,[],[],opts);

beta=xopt(1:n);

%%%%%%%%%%%%%%%%%%%%%%%%%%%
function results_display(N,z,display,nvar,scalevars,dd,d0,epsil,RBFcalibrate)

if display
    fprintf('N = %4d: x = [',N);
    for j=1:nvar
        aux=z(j);
        if scalevars
            aux=aux*dd(j)+d0(j);
        end
        fprintf('%5.4f',aux);
        if j<nvar
            fprintf(', ');
        end
    end
    fprintf(']')
    if RBFcalibrate
        fprintf(', RBF epsil = %5.2f',epsil);
    end
    fprintf('\n');
end

%%%%%%%%%%%%%%%
function [theta,itheta,M,MM,iM]=rbf_calibrate(X,I,Ieq,M,N,ibest,sepvalue,rbf,epsil,comparetol,display,thetas,MM,iM,itheta)
% calibrate scaling of epsil parameter in RBF by cross-validation

if display
    fprintf('Recalibrating RBF: ');
end

nth=numel(thetas);
success=zeros(nth,1);

for k=1:nth
    
    epsilth=epsil*thetas(k);

    % Update matrix MM containing RBF values for all thetas
    % MM is a maxevals-by-maxevals-by-numel(thetas) matrix
    % to avoid recomputing RBF values again. It is updated up to step N
    % only for the current theta, indexed by itheta
    if k==itheta
        MM(iM+1:N,1:N,itheta)=M(iM+1:N,1:N); % values already computed for current theta
        MM(1:iM,iM+1:N,itheta)=M(1:iM,iM+1:N); 
    else 
        for j=iM+1:N
            for h=1:N
                MM(j,h,k)=rbf(X(j,:)',X(h,:)',epsilth);
                MM(h,j,k)=MM(j,h,k);
            end
        end
    end

    Ncomparisons=0;
    for i=1:N
        if i~=ibest
            Xi=X(1:N,:);
            Xi(i,:)=[];
            if ibest>i
                newibest=ibest-1;
            else
                newibest=ibest;
            end
            
            Ii=I;
            isi=[];
            if ~isempty(I)
                isi=(I(:,1)==i | I(:,2)==i);
                Ii(isi,:)=[];
                Ii(Ii(:,1)>i,1)=Ii(Ii(:,1)>i,1)-1;
                Ii(Ii(:,2)>i,2)=Ii(Ii(:,2)>i,2)-1;
            end
            Ieqi=Ieq;
            iseqi=[];
            if ~isempty(Ieq)
                iseqi=(Ieq(:,1)==i | Ieq(:,2)==i);
                Ieqi(iseqi,:)=[];
                Ieqi(Ieqi(:,1)>i,1)=Ieqi(Ieqi(:,1)>i,1)-1;
                Ieqi(Ieqi(:,2)>i,2)=Ieqi(Ieqi(:,2)>i,2)-1;
            end
            
            Mi=MM(1:N,1:N,k);
            Mi(i,:)=[];
            Mi(:,i)=[];
            
            Wi=get_weights(Xi,Ii,Ieqi,Mi,N-1,newibest,sepvalue);
            
            % Compute RBF @X(i,:)'
            FH=zeros(N,1);
            FH([1:i-1,i+1:N])=Mi*Wi; % rbf at samples
            xx=X(i,:)';
            v=zeros(N-1,1);
            for j=1:N-1
                v(j)=rbf(Xi(j,:),xx',epsilth);
            end
            FH(i)=v'*Wi;
            
            % Cross validation
            jj=find(isi);
            Ncomparisons=Ncomparisons+numel(jj);
            for h=1:numel(jj)
                j=jj(h);
                i1=I(j,1);
                i2=I(j,2);
                if FH(i1)<=FH(i2)-comparetol
                    success(k)=success(k)+1;
                end
            end
            jj=find(iseqi);
            Ncomparisons=Ncomparisons+numel(jj);
            for h=1:numel(jj)
                j=jj(h);
                i1=Ieq(j,1);
                i2=Ieq(j,2);
                if abs(FH(i1)-FH(i2))<=comparetol
                    success(k)=success(k)+1;
                end
            end
        end
    end
    if display
        fprintf('.');
    end
    success(k)=success(k)/Ncomparisons*100; % NOTE: normalization is only for visualization purposes
end

% Find theta such that success is max, and closest to 1 among maximizers
[~,imax]=max(success);
theta_max=thetas(imax);
[~,ii]=min((theta_max-1).^2); % get the theta closest to 1 among maxima
theta=theta_max(ii);
itheta=imax(ii);

iM=N;

% Update matrix M
M(1:N,1:N)=MM(1:N,1:N,itheta);

if display
    fprintf(' done.\n');
end
